##### Script for making and evaluating the final classifiers for AML subtypes #####

setwd("Documents/R_work")
library(pamr)

# First, load data generated by the script "Data for pamr":

load("GRSet_beta_datasets.Rdata")
load("AML_class_vectors.Rdata")

##### Subset the beta data for known samples #####

# Choosing the vectors for subsetting the array data (cpg.freq$index[1:x])
# Three vectors for each subtype, number of CpG sites chosen are based on the look of the curves in the cpg.freq plots
# GRSet_beta_classifierX is the data that should be used for the final training with pamr.train

GRSet_beta_classifier1.t821 <- GRSet_beta_known[cpg.freq.t821$index[1:5], ]
GRSet_beta_classifier2.t821 <- GRSet_beta_known[cpg.freq.t821$index[1:10], ]
GRSet_beta_classifier3.t821 <- GRSet_beta_known[cpg.freq.t821$index[1:15], ]

GRSet_beta_classifier1.inv16 <- GRSet_beta_known[cpg.freq.inv16$index[1:10], ]
GRSet_beta_classifier2.inv16 <- GRSet_beta_known[cpg.freq.inv16$index[1:61], ]
GRSet_beta_classifier3.inv16 <- GRSet_beta_known[cpg.freq.inv16$index[1:113], ]

GRSet_beta_classifier1.mono7 <- GRSet_beta_known[cpg.freq.mono7$index[1:6], ]
GRSet_beta_classifier2.mono7 <- GRSet_beta_known[cpg.freq.mono7$index[1:13], ]
GRSet_beta_classifier3.mono7 <- GRSet_beta_known[cpg.freq.mono7$index[1:22], ]

GRSet_beta_classifier1.MLL <- GRSet_beta_known[cpg.freq.MLL$index[1:13], ]
GRSet_beta_classifier2.MLL <- GRSet_beta_known[cpg.freq.MLL$index[1:49], ]
GRSet_beta_classifier3.MLL <- GRSet_beta_known[cpg.freq.MLL$index[1:104], ]

# Make lists that will be input for pamr.train, making these final classifiers

t821.classifier1.list <- list(x = GRSet_beta_classifier1.t821, y = t821_class_vector)
t821.classifier2.list <- list(x = GRSet_beta_classifier2.t821, y = t821_class_vector)
t821.classifier3.list <- list(x = GRSet_beta_classifier3.t821, y = t821_class_vector)

inv16.classifier1.list <- list(x = GRSet_beta_classifier1.inv16, y = inv16_class_vector)
inv16.classifier2.list <- list(x = GRSet_beta_classifier2.inv16, y = inv16_class_vector)
inv16.classifier3.list <- list(x = GRSet_beta_classifier3.inv16, y = inv16_class_vector)

mono7.classifier1.list <- list(x = GRSet_beta_classifier1.mono7, y = mono7_class_vector)
mono7.classifier2.list <- list(x = GRSet_beta_classifier2.mono7, y = mono7_class_vector)
mono7.classifier3.list <- list(x = GRSet_beta_classifier3.mono7, y = mono7_class_vector)

MLL.classifier1.list <- list(x = GRSet_beta_classifier1.MLL, y = MLL_class_vector)
MLL.classifier2.list <- list(x = GRSet_beta_classifier2.MLL, y = MLL_class_vector)
MLL.classifier3.list <- list(x = GRSet_beta_classifier3.MLL, y = MLL_class_vector)

# Make list of all these lists to be able to use with later scripts

final.classifiers.list <- list(t821.classifier1.list, t821.classifier2.list, t821.classifier3.list, inv16.classifier1.list, inv16.classifier2.list, inv16.classifier3.list, mono7.classifier1.list, mono7.classifier2.list, mono7.classifier3.list, MLL.classifier1.list, MLL.classifier2.list, MLL.classifier3.list)

##### Functions for training the final classifiers and getting the error rates #####

get.error <- function(cv.results) {
  ncpgs <- cv.results$size[1] # Include all cpg sites!
  all_errors <- which(cv.results$size == cv.results$size[1]) # gives all indices for the rows with max nr cpgs
  max.error <- cv.results$error[which.max(cv.results$error[all_errors])] # gives the error rate for the index of the highest error
  return(max.error)
}

train.and.evaluate.final <- function(error.rate.final, classifier.list) {
  trained.data <- pamr.train(classifier.list)
  cv.results <- pamr.cv(trained.data, classifier.list)
  error <- get.error(cv.results)
  result <- list(trained.data = trained.data, error = error)
  return(result)
}

##### Loop for training the final classifiers and getting the error rates #####

# Since the pamr.train function used will be randomized it will not give the same result each time. 
# Therefore, train the classifiers 50 times and investigate the distribution of error rates for the triplets of classifiers

acc.errors <- c(0,0,0,0,0,0,0,0,0,0,0,0) # Initiate vector for storing the accumulative errors found when training the final classifiers

for (i in c(1:50)) {
  error.rate.final <- vector() # Initiate vector for storing error rates
  for (j in c(1:length(final.classifiers.list))) {
    classifier.and.error <- train.and.evaluate.final(error.rate.final, final.classifiers.list[[j]])
    #classifier.data <- classifier.and.error$trained.data
    #classifier.data.list[[j]] <- classifier.data
    #assign(paste0("classifier.data", ".", i), classifier.data) # classifier.data.X will be the classifier data for element X in final.classifiers.list
    error.rate.final[j] <- classifier.and.error$error*77 # Mult. with no of samples to get the actual number of errors
  }
  acc.errors <- acc.errors + error.rate.final
}

# Result:
#> acc.errors
#[1]   0   0   0  49  48  36  31   0   9 100 151 150

save(acc.errors, file = "accumulative_errors.Rdata")

# Make figure for this data, see script plot.acc.errors.R

# Choose the final classifiers based on this:

# t821  - classifier 3 (classifier.data.3)
# inv16 - classifier 3 (classifier.data.6)
# mono7 - classifier 2 (classifier.data.8)
# MLL   - classifier 1 (classifier.data.10)

# Run the inner loop again to generate the classifier.data variables and store them in a list
# Check that the error rates for the run corresponds to the acc.errors above, that they show the same pattern

for (j in c(1:length(final.classifiers.list))) {
  classifier.and.error <- train.and.evaluate.final(error.rate.final, final.classifiers.list[[j]])
  classifier.data <- classifier.and.error$trained.data
  assign(paste0("classifier.data", ".", i), classifier.data) # classifier.data.X will be the classifier data for element X in final.classifiers.list
  error.rate.final[j] <- classifier.and.error$error*77 # Mult. with no of samples to get the actual number of errors
}

classifier.data.t821 <- classifier.data.3
classifier.data.inv16 <- classifier.data.6
classifier.data.mono7 <- classifier.data.8
classifier.data.MLL <- classifier.data.10

save(classifier.data.t821, classifier.data.inv16, classifier.data.mono7, classifier.data.MLL, file = "final_classifiers.Rdata")



##### Using the final classifiers on unknown data #####

# Subset the unknown data to the relevant CpG sites, then use pamr.predict
# Load final_classifiers.Rdata if needed

GRSet_beta_unknown.t821cpgs <- GRSet_beta_unknown[cpg.freq.t821$index[1:15], ] # Use all cpg sites found for this classifier
predicted <- pamr.predict(classifier.data.t821, GRSet_beta_unknown.t821cpgs, threshold = 0) #threshold = 0 to use all cpg sites
summary(predicted) 

# not t(8;21)     t(8;21) 
# 58           0 

t821.predicted <- which(predicted %in% "t(8;21)") # gives a vector of indexes (unknown data) that are predicted t821

GRSet_beta_unknown.inv16cpgs <- GRSet_beta_unknown[cpg.freq.inv16$index, ] # Use all cpg sites found for this classifier
predicted <- pamr.predict(classifier.data.inv16, GRSet_beta_unknown.inv16cpgs, threshold = 0) #threshold = 0 to use all cpg sites
summary(predicted) 

# inv(16) not inv(16) 
# 3          55 

inv16.predicted <- which(predicted %in% "inv(16)") # gives a vector of indexes (unknown data) that are predicted inv16

GRSet_beta_unknown.mono7cpgs <- GRSet_beta_unknown[cpg.freq.mono7$index[1:13], ] # Use 13 most common cpg sites
predicted <- pamr.predict(classifier.data.mono7, GRSet_beta_unknown.mono7cpgs, threshold = 0) #threshold = 0 to use all cpg sites
summary(predicted) 

# mono 7 not mono 7 
# 4         54 

mono7.predicted <- which(predicted %in% "mono 7") # gives a vector of indexes (unknown data) that are predicted mono7

GRSet_beta_unknown.MLLcpgs <- GRSet_beta_unknown[cpg.freq.MLL$index[1:13], ] # Use 13 most common cpg sites
predicted <- pamr.predict(classifier.data.MLL, GRSet_beta_unknown.MLLcpgs, threshold = 0) #threshold = 0 to use all cpg sites
summary(predicted) 

# MLL not MLL 
# 7      51 

MLL.predicted <- which(predicted %in% "MLL") # gives a vector of indexes (unknown data) that are predicted MLL

save(t821.predicted, inv16.predicted, mono7.predicted, MLL.predicted, file = "subtypes_predicted.Rdata")
